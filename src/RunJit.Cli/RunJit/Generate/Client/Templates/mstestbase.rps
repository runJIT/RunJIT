using AspNetCore.Simple.MsTest.Sdk;
using DotNetTool.Service;
using Extensions.Pack;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace $namespace$
{
    [TestClass]
    public abstract class ApiTestBase
    {
        private static ApiTestBase<Startup>? _apiTestBase;
        private static HttpClient? _httpClient;
      
        // In this sample we currently use assembly initialize, to save performance, but you can do it also different.
        [AssemblyInitialize]
        public static async Task AssemblyInitializeAsync(TestContext _)
        {
            // 1. When we are in debug mode (DEV local) we start the needed docker container
            //    This is a POC because we dont know yet how the end solution looks like
            //    ToDo: Tear down of docker before start, to go sure container is clean and new
            //          https://confluence.siemens.cloud/gms/display/PC/4.115.2+Test.Containers
            //          https://jira.siemens.cloud/gms/browse/PCD-7733
            if (typeof(ApiTestBase).Assembly.IsCompiledInDebug())
            {
                var dockerRunResult = await DotNetTool.RunAsync("docker", $"run -d -p 8001:8000 --name {DynamoDbContainerName} amazon/{DynamoDbContainerName} -jar DynamoDBLocal.jar -sharedDb").ConfigureAwait(false);
                Assert.AreEqual(0, dockerRunResult.ExitCode, $"Dynamo DB: {DynamoDbContainerName} could not be started. Please check if you have docker installed");
            }

            // 2. Super simple just use the provided API test base class and you are ready to go
            var environmentVariables = EmbeddedFile.GetFileContentFrom("Properties.EnvironmentVariables.json")
                                                   .FromJsonStringAs<Dictionary<string, string>>()
                                                   .Select(keyValue => (keyValue.Key, keyValue.Value)).ToArray();

            // 3. Setup api test base environment
            _apiTestBase = new ApiTestBase<Startup>("Development", (services, config) =>
            {                
                services.Add$clientName$(config);
                services.Add$clientName$Factory(config);
            },
            environmentVariables);
                          
             // 4. We need once the http client to communicate with the started api
            _httpClient = _apiTestBase.CreateClient(new WebApplicationFactoryClientOptions { AllowAutoRedirect = false });
    
            // Add your client authentication here !
    
            // 5. Setup client factory to use the semantic client
            var $clientName$Factory = _apiTestBase.Services.GetOrThrowMissingException<I$clientName$Factory>();
            $clientName$ = $clientName$Factory.CreateFrom(_httpClient);          
        }
    	      
        protected static $clientName$ $clientName$ { get; private set; } = null!;
    
        [AssemblyCleanup]
        public static async Task AssemblyCleanupAsync()
        {
            // 1. Dispose the api test environment
            await _apiTestBase.DisposeAsync().ConfigureAwait(false);
            
            // 2. Dispose the http client
            Client.Dispose();
            
            // 3. When we are in debug mode (DEV local) we start the needed docker container
            //    and we have to shut down and remove it ! to have a clean container next startup
            if (typeof(ApiTestBase).Assembly.IsCompiledInDebug())
            {
                await DotNetTool.RunAsync("docker", $"stop {DynamoDbContainerName}").ConfigureAwait(false);
                await DotNetTool.RunAsync("docker", $"rm {DynamoDbContainerName}").ConfigureAwait(false);
            }
        }
    }
}